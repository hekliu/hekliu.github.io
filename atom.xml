<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘庆龙 | Hekliu</title>
  
  <subtitle>不为失败找借口，只为成功找方法！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hekliu.github.io/"/>
  <updated>2019-10-04T14:43:11.598Z</updated>
  <id>https://hekliu.github.io/</id>
  
  <author>
    <name>刘庆龙</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java中的I/O演进之路</title>
    <link href="https://hekliu.github.io/2019/10/03/java%E4%B8%AD%E7%9A%84I-O%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/"/>
    <id>https://hekliu.github.io/2019/10/03/java中的I-O演进之路/</id>
    <published>2019-10-03T15:15:49.000Z</published>
    <updated>2019-10-04T14:43:11.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-O基础入门"><a href="#I-O基础入门" class="headerlink" title="I/O基础入门"></a>I/O基础入门</h2><p>Java1.4 之前的早期版本，Java对I/O的支持并不完善，开人员在开发高性能I/O程序时是有非常大的困难的,总结有以下几点:</p><ul><li>没有数据缓存区，I/O性能存在问题</li><li>没有C或者C++中的Channel概念，只有输入和输出流</li><li>同步阻塞I/O通行(BIO)，通常会导致通信线程被长时间阻塞。</li><li>文件的字符集有限，硬件移值性不好</li></ul><a id="more"></a><p>因为以上的一些缺陷,所以在很长的一段时间内，服务器端的开发领域一直被C++和C长期占据。</p><h2 id="Linux-网络I-O模型简介"><a href="#Linux-网络I-O模型简介" class="headerlink" title="Linux 网络I/O模型简介"></a>Linux 网络I/O模型简介</h2><p><code>Linux</code>的内核将所有的外部设备都看作一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个 <code>file descriptor</code>(fd, 文件描述符)。而对一个socket的读写也会有相应的描述符，称为 <code>socketfd</code>(socket 描述符)，描述符就是一个数字，它指向内核中的一个<code>结构体</code>(文件路径，数据区等属性)。</p><h3 id="UNIX网络编程对I-O模型的分类，UNIX提供了5种I-O模型"><a href="#UNIX网络编程对I-O模型的分类，UNIX提供了5种I-O模型" class="headerlink" title="UNIX网络编程对I/O模型的分类，UNIX提供了5种I/O模型"></a>UNIX网络编程对I/O模型的分类，UNIX提供了5种I/O模型</h3><p><strong>阻塞IO模型(BIO)：</strong>最常用的I/O模型就是阻塞模型，缺省的情形下，所有的文件操作都是阻塞的。我们以套接字接口为例来讲解此模型:在进程空间中调用recvfrom，其系统调用直到数据包到达且被复制到应用进程的缓冲区或者发生错误的时候才返回，否则，在此期间一直会等待，进程在从调用recvfrom开始到它返回的整段时间都是被阻塞的，因此被称为阻塞I/O模型。 如下图：</p><p><img src="/images/java中的IO演进之路/BIO.png" alt="BIO" title="BIO.png"></p><p><strong>非阻塞(NIO)：</strong> <code>refcvfrom</code>从应用层到内核的时候，如果该缓冲区没有数据的话，就直接返回一个<code>EWOULDBLOCK</code>错误，一般来说非阻塞<code>I/O模型</code>进行轮寻检查这个状态，看内核是不是有数据到来。</p><p><img src="/images/java中的IO演进之路/NOBIO.png" alt="NOBIO" title="NOBIO.png"></p><p><strong>I/O复用模型：</strong> <code>Linux</code> 提供<code>select/poll</code>，进程通过将一个或多个fd传递给<code>select</code> 或<code>poll</code>系统调用，阻塞在<code>select</code>操作上，这样<code>select/poll</code>可以帮助我们侦测多个fd是否处于就绪状态，<code>select/poll</code>是顺序扫描fd是否就绪，而且支持的<code>fd</code>数量有限，因此它的使用受到一些限制，<code>Linux</code>还提供了一个<code>epoll</code>系统调用，<code>epoll</code>使用基于事件驱动方式代替顺序扫描，因此性能更高，当有fd准备就绪时，就立即回调函数<code>rollback</code>。如下图所示:</p><p><img src="/images/java中的IO演进之路/IORE.png" alt="IORE" title="IORE.png"></p><p><strong>信号驱动I/O模型：</strong>首先开启套接口信号驱动I/O功能，并通过系统调用<code>sigaction</code>执行一个信号处理函数(此系统调用立即返回，进程继续工作，它是非阻塞的)。当数据准备就绪时，就为该进程生成一个<code>SIGIO信号</code>，通过信号回调通知应用程序调用<code>recvfrom</code>来读取数据，并通知主循环函数处理数据，如下图：</p><p><img src="/images/java中的IO演进之路/SIIO.png" alt="SIIO" title="SIIO.png"></p><p><strong>异步I/O：</strong>告知内核启动某个操作，并让内核在整个操作完成后(包括将数据从内核复制到用户自己的缓冲区)通知我们。这种模型与信号量驱动模型的主要区别是: <strong>信号驱动I/O由内核通知我们何时可以开始一个I/O操作，异步Java NIO的核心类库多路复用器selector 就是基于 epoll 的多路复用技术实现。</strong>I/O模型由内核通知我们I/O已经完成。如下图：</p><p><img src="/images/java中的IO演进之路/AIO.png" alt="AIO" title="AIO.png"></p><h2 id="I-O多路复用技术"><a href="#I-O多路复用技术" class="headerlink" title="I/O多路复用技术"></a>I/O多路复用技术</h2><p>在I/O编程过程中，当需要同时处理多个客户端接入请求时，可以利用多个线程或者I/O多路复用技术进行处理，I/O多路复用技术通过把多个I/O的阻塞复用到同一个<code>select</code>的阻塞上，从而使得系统在单线程中可以同时处理多个客户端请求，与传统的多线程/多进程，模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源，I/O多路复用的主要应用场景如下：</p><ul><li>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字</li><li>服务器需要同时处理多种网络协议的套接字</li></ul><p>目前支持I/O多路复用的系统调用有<strong>select、pselect、poll、epoll</strong>, 在Linux网络编程过程中，很长一段时间都使用select做轮询和网络事件通知，然而select的一些固有缺陷导致了它受到了很大的限制，最终Linux不得不在新的内核版本中寻找select的替代方案，最终选择了epoll与select的原理比较类似。</p><p>为了克服 select的缺点， epoll 做了很大的改进:</p><p>1.支持一个进程打开的socket描述符(FD)不受限制(仅受限于操作系统的最大文件句柄数。</p><blockquote><p>select最大的缺陷就是单个进程锁打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024,对于那些需要支持上万个TCP连接的大型服务器来说显然太少了。可以选择修改这个宏然后重新编译内核，不过这会带来网络效率的下降。我们也可以通过选择多个进程的方案(传统的Apache 方案)解决这个问题，不过虽然在Linux上创建进程的代价比较小，但仍然是不可忽视的，另外，进程间的数据交换非常麻烦，对于java来说，由于没有共享内存，需要通过Socket通讯或者其他方式进行数据同步，这带来了额外的性能损耗，增加了程序的复杂度，所以这也不是一个完美的解决方案。 但是值得庆幸的是， epoll并没有这个限制，它所支持的FD上限是操作系统的最大文件句柄数，这个数字远远大于1024。例如: 在1GB内存的机器上大约10万个文件句柄左右，具体的值可以通过<code>cat /proc/sys/fs/file -max</code> 查看，通常情况下这个值跟系统的内存关系比较大。</p></blockquote><p>2.I/O效率不会随着FD数目的增加而线性下降。</p><blockquote><p>传统 select/poll的另一个致命的弱点，就是当你拥有一个很大的socket 集合时，由于网络的延时或者链路空闲，任一时刻只有少部分的socket是”活跃”的,但是 select/poll 每次调用都会线性扫描全部的集合，导致效率呈现线性下降。epoll 不存在这个问题，它只会对”活跃”的socket 进行操作——这是因为在内核实现中，epoll 是根据每个fd上面的callback函数实现的。那么，只有”活跃”的socket 才会去主动调用callback函数，其他idle状态的socket则不会。在这点上，epoll实现了一个伪AIO. 针对 epoll和select性能对比的benchmark 测试表明: 如果所有的socket都处于活跃状态——例如一个高速LAN环境，epoll并不比select/poll 效率高太多；相反，如果过多使用epoll_ctl， 效率相比还有稍微地降低。但是一旦使用 idle connections 模拟WAN环境，epoll的效率就远在select/poll 之上了。</p></blockquote><p>3.使用mmap加速内核与用户空间的消息传递。</p><blockquote><p>无论是select、poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存复制就显得非常重要，epoll是通过内核和用户空间mmap同一块内存来实现的。</p></blockquote><p>4.epoll的API更加简单。</p><h2 id="Java的I-O演进"><a href="#Java的I-O演进" class="headerlink" title="Java的I/O演进"></a>Java的I/O演进</h2><p>在JDK 1.4 推出<code>Java NIO</code> 之前，基于Java 的所有Socket 通信都采用同步阻塞模式(BIO)，这种一请求一问答的通信模型简化了上层的应用开发，但是在性能和可靠性方面却存在巨大的瓶颈。因此很长的一段时间里，大型的应用服务器都采用 <code>C</code> 或者 <code>C++</code> 语言开发，因为他们可以直接使用操作系统中的异步I/O或者AIO能力，当并发访问量增大、响应时间延迟增大之后，采用<code>Java BIO</code>开发的服务端软件只有通过硬件的不断扩容来满足高并发和低延时，它极大的增加了企业的成本，并且随着集群规模的不断膨胀，系统的可维护性也面临巨大的挑战，只有通过采购性能更好的硬件服务器来解决问题，这导致恶性的循环。</p><p>正是 Java 传统的BIO的劣性，才使得Java 支持非阻塞I/O的呼声日渐个高涨，最终 <code>JDK 1.4</code> 中提供了新的NIO 类库，Java也可以支持非阻塞I/O了。</p><h2 id="Java-的I-O-发展"><a href="#Java-的I-O-发展" class="headerlink" title="Java 的I/O 发展"></a>Java 的I/O 发展</h2><p>JDK1.4 新增 java.nio 包，提供了很多进行异步I/O开发的API和类库，主要的类和接口如下：</p><ul><li>进行异步I/O操作的缓冲区ByteBuffer等;</li><li>进行异步I/O操作的管道Pipe;</li><li>进行各种I/O操作(异步或者同步)的Channel，包括<code>ServerSocketChannel</code>和<code>SocketChannel</code>;</li><li>多种字符集的编码能力和解码能力;</li><li>实现非阻塞I/O操作的多路复用器selector;</li><li>基于流行的Perl实现的正则表达式类库;</li><li>基于流行的Perl 实现的正则表达式类库;</li><li>文件通道<code>FileChannel</code>。</li></ul><p>新的<code>NIO类库</code>的提供极大的促进基于Java 的<code>异步非阻塞编程</code>的发展和应用,但是，它依然有不完善的地方，特别是对文件系统的处理能力仍显得不足，主要的问题如下：</p><ul><li>没有统一的文件属性(例如读写权限)</li><li>API能力比较弱，例如目录的级联创建和递归遍历，往往需要自己实现</li><li>底层存储系统的一些高级API无法使用</li><li>所有的文件操作都是同步阻塞调用，不支持异步文件读写操作</li></ul><p>2011 年 <code>JDK1.7</code>正式发布，它的一个比较大的亮点是将原来的NIO类库进行了升级，被称为 <code>NIO2.0</code>， 它主要有如下三个方面的改进：</p><ul><li>提供能够批量获取文件属性的API，这些API具有平台无关性，不与特定的文件系统相耦合，另外它还提供了标准文件系统的SPI，供各个服务提供商扩展实现</li><li>提供AIO功能，支持基于文件的异步操作和针对网络套接字的异步操作</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;I-O基础入门&quot;&gt;&lt;a href=&quot;#I-O基础入门&quot; class=&quot;headerlink&quot; title=&quot;I/O基础入门&quot;&gt;&lt;/a&gt;I/O基础入门&lt;/h2&gt;&lt;p&gt;Java1.4 之前的早期版本，Java对I/O的支持并不完善，开人员在开发高性能I/O程序时是有非常大的困难的,总结有以下几点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有数据缓存区，I/O性能存在问题&lt;/li&gt;
&lt;li&gt;没有C或者C++中的Channel概念，只有输入和输出流&lt;/li&gt;
&lt;li&gt;同步阻塞I/O通行(BIO)，通常会导致通信线程被长时间阻塞。&lt;/li&gt;
&lt;li&gt;文件的字符集有限，硬件移值性不好&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="netty" scheme="https://hekliu.github.io/categories/netty/"/>
    
    
      <category term="I/O" scheme="https://hekliu.github.io/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>Java并发(一)</title>
    <link href="https://hekliu.github.io/2019/10/02/Java%E5%B9%B6%E5%8F%91-%E4%B8%80/"/>
    <id>https://hekliu.github.io/2019/10/02/Java并发-一/</id>
    <published>2019-10-02T14:58:34.000Z</published>
    <updated>2019-10-04T10:41:11.891Z</updated>
    
    <content type="html"><![CDATA[<p>我们在找工作时，经常在招聘信息上看到有这么一条:有构建大型互联网服务及高并发等经验，你第一时间想到的是媒体常说的双十一吗？带着问题，我们一起思考技术….</p><a id="more"></a><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><blockquote><p>它是互联网分布式系统架构设计中必须考虑的因素之一，通常是指，保证系统能够同时并行化处理海量请求</p></blockquote><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p><strong>同步：</strong>发送一个请求，等待返回，然后再发送下一个请求。<code>提交请求</code> -&gt; <code>等待服务器处理</code> -&gt; <code>处理完返回</code>，此期间客户端浏览器不能干任何事<br><strong>异步：</strong>发送一个请求，不等待返回，随时可以再发送下一个请求。<code>提交请求</code> -&gt; <code>服务器处理</code>（这时浏览器仍然可以作其他事情）-&gt; <code>处理完毕</code></p><p><img src="/images/java并发/pic-1.png" alt="同步和异步" title="tongbuyibu.png"></p><p>从上图可以知道，随着实时间的轨迹，同步一步一步的执行着，在异步中，当一个异步过程调用发出后，调用者不能立即得到结果，实际上会开启一个线程执行这部分内容，这个线程处理完了之后，通过状态，通知和回调来通知调用者来处理。</p><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p><img src="/images/java并发/pic-2.png" alt="并发和并行" title="bingxinghebingfa.png"></p><p><strong>单核CPU(单处理器)上，只可能存在并发而不可能存在并行。</strong> 并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）</p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p><code>临界区</code>用来表示一种公共资源或者说是共享数据，可以被多个线程使用，但是每一次，只能有一个线程使用它，一旦临界去资源被占用，其他线程想要使用这个资源，就必须等待。</p><p><img src="/images/java并发/pic-3.png" alt="临界区" title="lingjiequ.png"></p><p>这就是我们编程中经常要加锁的地方，如 <code>synchronized</code> 关键字，或是 <code>Lock</code> 接口。</p><blockquote><p>阻塞和非阻塞</p></blockquote><ul><li>阻塞(Blocking)和非阻塞(Non-Blocking)通常用来形容多线程间的相互影响，比如一个线程占用临界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中进行等待，等待会导致线程挂起，这种情况就是阻塞。如果占用资源的线程一直不愿意释放资源，那么其它所有阻塞在这个临界区上的线程都不能工作。</li><li>非阻塞允许多个线程同时进入临界区。</li></ul><h2 id="死锁、饥饿、活锁"><a href="#死锁、饥饿、活锁" class="headerlink" title="死锁、饥饿、活锁"></a>死锁、饥饿、活锁</h2><p><strong> 死锁：</strong> 指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><p><code>互斥条件：</code>线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到资源被释放。</p><p><code>请求和保持条件：</code>线程T1至少已经保持了一个资源R1占用,但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。</p><p><code>不剥夺条件：</code>线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。</p><p><code>环路等待条件：</code>在死锁发生时，必然存在一个“进程-资源环形链”，即：{p0,p1,p2,…pn},进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待</p><p><strong> 活锁：</strong> 指线程T1可以使用资源，但它很礼貌，让其他线程先使用资源，线程T2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。</p><blockquote><p>在街上遇到一妹子，刚好她朝着你的反方向走，与你正面碰到，你们都想让彼此过去。你往左边移，她也往左边移，两人还是无法过去。这时你往右边移，她也往右边移，如此循环下去。</p></blockquote><p><strong>饥饿：</strong> 指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求……，T2可能永远等待。</p><blockquote><p>有两条道A和B上都堵满了车辆，其中A道堵的时间最长，B相对相对堵的时间较短，这时，前面道路已疏通，交警按照最佳分配原则，示意B道上车辆先过，B道路上过了一辆又一辆，A道上排队时间最长的确没法通过，只能等B道上没有车辆通过的时候再等交警发指令让A道依次通过，这也就是 <code>ReentrantLock</code> 显示锁里提供的不公平锁机制（当然了，<code>ReentrantLock</code> 也提供了公平锁的机制，由用户根据具体的使用场景而决定到底使用哪种锁策略），不公平锁能够提高吞吐量但不可避免的会造成某些线程的饥饿。</p></blockquote><h2 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h2><p>分为 <code>阻塞</code> 和 <code>非阻塞</code>（非阻塞分为<code>无障碍</code>、<code>无锁</code>、<code>无等待</code>）</p><p><strong> 阻塞 </strong></p><p>当一个线程进入临界区后，其他线程必须等待</p><p><strong> 无障碍 </strong> </p><ul><li>无障碍是一种最弱的非阻塞调度</li><li>可自由出入临界区</li><li>无竞争时，有限步内完成操作</li><li>有竞争时，回滚数据</li></ul><p>和<code>非阻塞调度</code>相比呢，<code>阻塞调度</code>是一种悲观的策略，它会认为说一起修改数据是很有可能把数据改坏的。而<code>非阻塞调度</code>呢，是一种乐观的策略，它认为大家修改数据未必把数据改坏。 但是它是一种 <code>宽进严出</code> 的策略，当它发现一个进程在<code>临界区</code>内发生了数据竞争，产生了冲突，那么<code>无障碍的调度</code>方式则会回滚这条数据。</p><p>在这个<code>无障碍的调度</code>方式当中，所有的线程都相当于在拿去一个系统当前的一个快照。他们一直会尝试拿去的快照是有效的为止。</p><p><strong> 无锁 </strong></p><ul><li>是无障碍的</li><li>保证有一个线程可以胜出</li></ul><p>与<code>无障碍</code>相比，<code>无障碍</code>并不保证有竞争时一定能完成操作，因为如果它发现每次操作都会产生冲突，那它则会不停地尝试。如果临界区内的线程互相干扰，则会导致所有的线程会卡死在<code>临界区</code>，那么系统性能则会有很大的影响。</p><p>而无锁增加了一个新的条件，保证每次竞争有一个线程可以胜出，则解决了无障碍的问题。至少保证了所有线程都顺利执行下去。</p><p>下面代码是Java中典型的无锁计算代码:</p><figure class="highlight gcode hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">while</span> <span class="hljs-comment">(!atomicVar.compareAndSet(localVar, localVar+1)</span>) &#123; </span><br><span class="line">    localVar = atomicVar.get<span class="hljs-comment">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 无等待 </strong></p><ul><li>无锁的</li><li>要求所有的线程都必须在有限步内完成</li><li>无饥饿的</li></ul><p><code>无等待</code>的前提是无锁的基础上的，无锁它只保证了临界区肯定有进也有出，但是如果进的优先级都很高，那么临界区内的某些优先级低的线程可能发生饥饿，一直出不了临界区。那么无等待解决了这个问题，它保证所有的线程都必须在有限步内完成，自然是无<code>饥饿</code>的。</p><p><code>无等待</code>是并行的最高级别，它能使这个系统达到最优状态。无等待的典型案例：只有读线程，没有写线程，那么这个则必然是无等待的。 如果既有读线程又有写线程，而每个写线程之前，都把数据拷贝一份副本，然后修改这个副本，而不是修改原始数据，因为修改副本，则没有冲突，那么这个修改的过程也是无等待的。最后需要做同步的只是将写完的数据覆盖原始数据。由于无等待要求比较高，实现起来比较困难，所以无锁使用得会更加广泛一些。</p><h2 id="关于并行的2个重要定律"><a href="#关于并行的2个重要定律" class="headerlink" title="关于并行的2个重要定律"></a>关于并行的2个重要定律</h2><p>两个定律都与加速比有关</p><blockquote><p>阿姆达尔定律</p></blockquote><p><strong> Amdahl定律(阿姆达尔定律)：定义了串行系统并行化后的加速比的计算公式和理论上限（加速比=优化前系统耗时/优化后系统耗时）</strong></p><p>一个程序（或者一个算法）可以按照 <code>是否可以被并行化</code> 分为下面两个部分：</p><ul><li>可以被并行化的部分</li><li>不可以被并行化的部分</li></ul><p>假设一个程序处理磁盘上的文件。这个程序的一小部分用来扫描路径和在内存中创建文件目录。做完这些后，每个文件交个一个单独的线程去处理。扫描路径和创建文件目录的部分不可以被并行化，不过处理文件的过程可以。</p><p><img src="/images/java并发/pic-4.png" alt="阿姆达尔定律" title="amuda.png"></p><blockquote><p>阿姆达尔定律</p></blockquote><p>增加CPU处理器的数量并不一定能起到有效的作用，提高系统内可并行化的模块比重，合理增加并行处理器数量，才能以最小的投入，得到最大的加速比。</p><blockquote><p>古斯塔夫森定律</p></blockquote><p><strong>Gustafson定律(古斯塔夫森)：</strong>说明处理器个数，串行比例和加速比之间的关系。</p><p><img src="/images/java并发/pic-5.png" alt="古斯塔夫森定律" title="gustafson.png"></p><p>只要有足够的并行化，那么<code>加速比</code>和<code>CPU个数</code>成正比。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在找工作时，经常在招聘信息上看到有这么一条:有构建大型互联网服务及高并发等经验，你第一时间想到的是媒体常说的双十一吗？带着问题，我们一起思考技术….&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://hekliu.github.io/categories/java/"/>
    
    
      <category term="java并发" scheme="https://hekliu.github.io/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>配置docker官方源并用yum安装docker</title>
    <link href="https://hekliu.github.io/2019/09/30/%E9%85%8D%E7%BD%AEdocker%E5%AE%98%E6%96%B9%E6%BA%90%E5%B9%B6%E7%94%A8yum%E5%AE%89%E8%A3%85docker/"/>
    <id>https://hekliu.github.io/2019/09/30/配置docker官方源并用yum安装docker/</id>
    <published>2019-09-30T08:12:07.000Z</published>
    <updated>2019-09-30T09:05:35.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、docker的官方安装文档："><a href="#一、docker的官方安装文档：" class="headerlink" title="一、docker的官方安装文档："></a>一、docker的官方安装文档：</h2><p><a href="https://docs.docker.com/engine/installation/linux/centos/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/centos/</a><br>由docker给的文档可以看出它也只是去配置了一个docker的yum源、然后就通过这个源来安装docker了；在这个文档下我们采用手工配置的方式。</p><a id="more"></a><h2 id="二、配置一个docker用的源："><a href="#二、配置一个docker用的源：" class="headerlink" title="二、配置一个docker用的源："></a>二、配置一个docker用的源：</h2><pre><code>1.为docker 增加一个新的yum配置文件；</code></pre><figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /etc/yum<span class="hljs-selector-class">.repos</span><span class="hljs-selector-class">.d</span>/docker.repo</span><br></pre></td></tr></table></figure><pre><code>2.docker.repo的内容如下</code></pre><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[docker-ce-stable]</span></span><br><span class="line"><span class="hljs-attr">name</span>=Docker CE Stable - <span class="hljs-variable">$basearch</span></span><br><span class="line"><span class="hljs-attr">baseurl</span>=https://download.docker.com/linux/centos/<span class="hljs-number">7</span>/<span class="hljs-variable">$basearch</span>/stable</span><br><span class="line"><span class="hljs-attr">enabled</span>=<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">0</span> #我把这里设置成了<span class="hljs-number">0</span>、说明我信任了这个源，不对它的rpm进行检察</span><br><span class="line"><span class="hljs-attr">gpgkey</span>=https://download.docker.com/linux/centos/gpg</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">[docker-ce-stable-debuginfo]</span></span><br><span class="line"><span class="hljs-attr">name</span>=Docker CE Stable - Debuginfo <span class="hljs-variable">$basearch</span></span><br><span class="line"><span class="hljs-attr">baseurl</span>=https://download.docker.com/linux/centos/<span class="hljs-number">7</span>/debug-<span class="hljs-variable">$basearch</span>/stable</span><br><span class="line"><span class="hljs-attr">enabled</span>=<span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">gpgkey</span>=https://download.docker.com/linux/centos/gpg</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">[docker-ce-stable-source]</span></span><br><span class="line"><span class="hljs-attr">name</span>=Docker CE Stable - Sources</span><br><span class="line"><span class="hljs-attr">baseurl</span>=https://download.docker.com/linux/centos/<span class="hljs-number">7</span>/source/stable</span><br><span class="line"><span class="hljs-attr">enabled</span>=<span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">gpgkey</span>=https://download.docker.com/linux/centos/gpg</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">[docker-ce-edge]</span></span><br><span class="line"><span class="hljs-attr">name</span>=Docker CE Edge - <span class="hljs-variable">$basearch</span></span><br><span class="line"><span class="hljs-attr">baseurl</span>=https://download.docker.com/linux/centos/<span class="hljs-number">7</span>/<span class="hljs-variable">$basearch</span>/edge</span><br><span class="line"><span class="hljs-attr">enabled</span>=<span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">gpgkey</span>=https://download.docker.com/linux/centos/gpg</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">[docker-ce-edge-debuginfo]</span></span><br><span class="line"><span class="hljs-attr">name</span>=Docker CE Edge - Debuginfo <span class="hljs-variable">$basearch</span></span><br><span class="line"><span class="hljs-attr">baseurl</span>=https://download.docker.com/linux/centos/<span class="hljs-number">7</span>/debug-<span class="hljs-variable">$basearch</span>/edge</span><br><span class="line"><span class="hljs-attr">enabled</span>=<span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">gpgkey</span>=https://download.docker.com/linux/centos/gpg</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">[docker-ce-edge-source]</span></span><br><span class="line"><span class="hljs-attr">name</span>=Docker CE Edge - Sources</span><br><span class="line"><span class="hljs-attr">baseurl</span>=https://download.docker.com/linux/centos/<span class="hljs-number">7</span>/source/edge</span><br><span class="line"><span class="hljs-attr">enabled</span>=<span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">gpgkey</span>=https://download.docker.com/linux/centos/gpg</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">[docker-ce-test]</span></span><br><span class="line"><span class="hljs-attr">name</span>=Docker CE Test - <span class="hljs-variable">$basearch</span></span><br><span class="line"><span class="hljs-attr">baseurl</span>=https://download.docker.com/linux/centos/<span class="hljs-number">7</span>/<span class="hljs-variable">$basearch</span>/test</span><br><span class="line"><span class="hljs-attr">enabled</span>=<span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">gpgkey</span>=https://download.docker.com/linux/centos/gpg</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">[docker-ce-test-debuginfo]</span></span><br><span class="line"><span class="hljs-attr">name</span>=Docker CE Test - Debuginfo <span class="hljs-variable">$basearch</span></span><br><span class="line"><span class="hljs-attr">baseurl</span>=https://download.docker.com/linux/centos/<span class="hljs-number">7</span>/debug-<span class="hljs-variable">$basearch</span>/test</span><br><span class="line"><span class="hljs-attr">enabled</span>=<span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">gpgkey</span>=https://download.docker.com/linux/centos/gpg</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">[docker-ce-test-source]</span></span><br><span class="line"><span class="hljs-attr">name</span>=Docker CE Test - Sources</span><br><span class="line"><span class="hljs-attr">baseurl</span>=https://download.docker.com/linux/centos/<span class="hljs-number">7</span>/source/test</span><br><span class="line"><span class="hljs-attr">enabled</span>=<span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">gpgkey</span>=https://download.docker.com/linux/centos/gpg</span><br></pre></td></tr></table></figure><h2 id="三、安装docker"><a href="#三、安装docker" class="headerlink" title="三、安装docker:"></a>三、安装docker:</h2><figure class="highlight vim hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-<span class="hljs-keyword">ce</span></span><br><span class="line">Loaded plugin<span class="hljs-variable">s:</span> fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">Resolving Dependencies</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package docker-<span class="hljs-keyword">ce</span>.x86_64 <span class="hljs-number">0</span>:<span class="hljs-number">17.03</span>.<span class="hljs-number">1</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos will <span class="hljs-keyword">be</span> installed</span><br><span class="line">--&gt; Processing Dependency: docker-<span class="hljs-keyword">ce</span>-selinux &gt;= <span class="hljs-number">17.03</span>.<span class="hljs-number">1</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos <span class="hljs-keyword">for</span> package: docker-<span class="hljs-keyword">ce</span>-<span class="hljs-number">17.03</span>.<span class="hljs-number">1</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos.x86_64</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package docker-<span class="hljs-keyword">ce</span>-selinux.noarch <span class="hljs-number">0</span>:<span class="hljs-number">17.03</span>.<span class="hljs-number">1</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos will <span class="hljs-keyword">be</span> installed</span><br><span class="line">--&gt; Finished Dependency Resolution</span><br><span class="line"></span><br><span class="line">Dependencies Resolved</span><br><span class="line"></span><br><span class="line">=====================================================================================================================================</span><br><span class="line"> Package                          Arch                  Version                                Repository                       Size</span><br><span class="line">=====================================================================================================================================</span><br><span class="line">Installin<span class="hljs-variable">g:</span></span><br><span class="line"> docker-<span class="hljs-keyword">ce</span>                        x86_64                <span class="hljs-number">17.03</span>.<span class="hljs-number">1</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos                docker-<span class="hljs-keyword">ce</span>-stable                 <span class="hljs-number">19</span> M</span><br><span class="line">Installing <span class="hljs-keyword">for</span> dependencie<span class="hljs-variable">s:</span></span><br><span class="line"> docker-<span class="hljs-keyword">ce</span>-selinux                noarch                <span class="hljs-number">17.03</span>.<span class="hljs-number">1</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos                docker-<span class="hljs-keyword">ce</span>-stable                 <span class="hljs-number">28</span> <span class="hljs-keyword">k</span></span><br><span class="line"></span><br><span class="line">Transaction Summary</span><br><span class="line">=====================================================================================================================================</span><br><span class="line">Install  <span class="hljs-number">1</span> Package (+<span class="hljs-number">1</span> Dependent package)</span><br><span class="line"></span><br><span class="line">Total download size: <span class="hljs-number">19</span> M</span><br><span class="line">Installed size: <span class="hljs-number">19</span> M</span><br><span class="line">Is this ok [<span class="hljs-keyword">y</span>/d/<span class="hljs-keyword">N</span>]: <span class="hljs-keyword">y</span></span><br></pre></td></tr></table></figure><h2 id="四、直接下载rpm包的方式来安装："><a href="#四、直接下载rpm包的方式来安装：" class="headerlink" title="四、直接下载rpm包的方式来安装："></a>四、直接下载rpm包的方式来安装：</h2><p>　　1.我在安装docker的时候发现下载的速度只有 <code>3kB/s</code> ，然而文件大小有<code>19M</code>。就在我感觉安装无望的时候，我机智的想到了自己直接把rpm下载下来，看了下docker.repo 发现centos7的源地址是 <code>https://download.docker.com/linux/centos/7/$basearch/stable</code> 所以我只要去<code>https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</code> 用迅雷(我是会员有加速)把rpm包下载下来就行了。</p><p><strong>下载如下文件：</strong></p><blockquote><p>docker-ce-17.03.0.ce-1.el7.centos.x86_64.rpm<br>docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch.rpm</p></blockquote><h2 id="五、安装docker"><a href="#五、安装docker" class="headerlink" title="五、安装docker:"></a>五、安装docker:</h2><figure class="highlight vim hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">ll</span></span><br><span class="line">total <span class="hljs-number">19096</span></span><br><span class="line">-rwxrwxrwx <span class="hljs-number">1</span> jianglexing jianglexing <span class="hljs-number">19521288</span> May <span class="hljs-number">30</span> <span class="hljs-number">20</span>:<span class="hljs-number">05</span> docker-<span class="hljs-keyword">ce</span>-<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos.x86_64.rpm</span><br><span class="line">-rw-r--r-- <span class="hljs-number">1</span> jianglexing jianglexing    <span class="hljs-number">29108</span> May <span class="hljs-number">30</span> <span class="hljs-number">20</span>:<span class="hljs-number">15</span> docker-<span class="hljs-keyword">ce</span>-selinux-<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos.noarch.rpm</span><br><span class="line">[root@workstudio docker]# yum localinstall *</span><br><span class="line">Loaded plugin<span class="hljs-variable">s:</span> fastestmirror, langpacks</span><br><span class="line">Examining docker-<span class="hljs-keyword">ce</span>-<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos.x86_64.rpm: docker-<span class="hljs-keyword">ce</span>-<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos.x86_64</span><br><span class="line">Marking docker-<span class="hljs-keyword">ce</span>-<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos.x86_64.rpm <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> installed</span><br><span class="line">Examining docker-<span class="hljs-keyword">ce</span>-selinux-<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos.noarch.rpm: docker-<span class="hljs-keyword">ce</span>-selinux-<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos.noarch</span><br><span class="line">Marking docker-<span class="hljs-keyword">ce</span>-selinux-<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos.noarch.rpm <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> installed</span><br><span class="line">Resolving Dependencies</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package docker-<span class="hljs-keyword">ce</span>.x86_64 <span class="hljs-number">0</span>:<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos will <span class="hljs-keyword">be</span> installed</span><br><span class="line">---&gt; Package docker-<span class="hljs-keyword">ce</span>-selinux.noarch <span class="hljs-number">0</span>:<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos will <span class="hljs-keyword">be</span> installed</span><br><span class="line">--&gt; Finished Dependency Resolution</span><br><span class="line"></span><br><span class="line">Dependencies Resolved</span><br><span class="line"></span><br><span class="line">=====================================================================================================================================</span><br><span class="line"> Package                 Arch         Version                          Repository                                               Size</span><br><span class="line">=====================================================================================================================================</span><br><span class="line">Installin<span class="hljs-variable">g:</span></span><br><span class="line"> docker-<span class="hljs-keyword">ce</span>               x86_64       <span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos          /docker-<span class="hljs-keyword">ce</span>-<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos.x86_64                <span class="hljs-number">65</span> M</span><br><span class="line"> docker-<span class="hljs-keyword">ce</span>-selinux       noarch       <span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos          /docker-<span class="hljs-keyword">ce</span>-selinux-<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos.noarch        <span class="hljs-number">43</span> <span class="hljs-keyword">k</span></span><br><span class="line"></span><br><span class="line">Transaction Summary</span><br><span class="line">=====================================================================================================================================</span><br><span class="line">Install  <span class="hljs-number">2</span> Packages</span><br><span class="line"></span><br><span class="line">Total size: <span class="hljs-number">65</span> M</span><br><span class="line">Installed size: <span class="hljs-number">65</span> M</span><br><span class="line">Is this ok [<span class="hljs-keyword">y</span>/d/<span class="hljs-keyword">N</span>]: <span class="hljs-keyword">y</span></span><br><span class="line">Downloading package<span class="hljs-variable">s:</span></span><br><span class="line">Running transaction check</span><br><span class="line">Running transaction test</span><br><span class="line">Transaction test succeeded</span><br><span class="line">Running transaction</span><br><span class="line">  Installing : docker-<span class="hljs-keyword">ce</span>-selinux-<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos.noarch                                                                  <span class="hljs-number">1</span>/<span class="hljs-number">2</span> </span><br><span class="line">setseboo<span class="hljs-variable">l:</span>  SELinux <span class="hljs-keyword">is</span> disabled.</span><br><span class="line">libsemanage.semanage_direct_install_info: Overriding docker module at lower priority <span class="hljs-number">100</span> with module at priority <span class="hljs-number">400</span>.</span><br><span class="line">  Installing : docker-<span class="hljs-keyword">ce</span>-<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos.x86_64                                                                          <span class="hljs-number">2</span>/<span class="hljs-number">2</span> </span><br><span class="line">  Verifying  : docker-<span class="hljs-keyword">ce</span>-<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos.x86_64                                                                          <span class="hljs-number">1</span>/<span class="hljs-number">2</span> </span><br><span class="line">  Verifying  : docker-<span class="hljs-keyword">ce</span>-selinux-<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos.noarch                                                                  <span class="hljs-number">2</span>/<span class="hljs-number">2</span> </span><br><span class="line"></span><br><span class="line">Installed:</span><br><span class="line">  docker-<span class="hljs-keyword">ce</span>.x86_64 <span class="hljs-number">0</span>:<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos                    docker-<span class="hljs-keyword">ce</span>-selinux.noarch <span class="hljs-number">0</span>:<span class="hljs-number">17.03</span>.<span class="hljs-number">0</span>.<span class="hljs-keyword">ce</span>-<span class="hljs-number">1</span>.el7.centos                   </span><br><span class="line"></span><br><span class="line">Complete!</span><br></pre></td></tr></table></figure><h2 id="六、启动docker"><a href="#六、启动docker" class="headerlink" title="六、启动docker:"></a>六、启动docker:</h2><figure class="highlight jboss-cli hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@workstudio docker]<span class="hljs-comment"># systemctl start docker</span></span><br><span class="line">[root@workstudio docker]<span class="hljs-comment"># ps -ef | grep docker</span></span><br><span class="line">root       4458      1  1 20<span class="hljs-function">:22</span> ?        00<span class="hljs-function">:00</span><span class="hljs-function">:00</span> <span class="hljs-string">/usr/bin/dockerd</span></span><br><span class="line">root       4465   4458  0 20<span class="hljs-function">:22</span> ?        00<span class="hljs-function">:00</span><span class="hljs-function">:00</span> docker-containerd -l unix:<span class="hljs-string">///var/run/docker/libcontainerd/docker-containerd.sock</span> <span class="hljs-params">--metrics-interval=0</span> <span class="hljs-params">--start-timeout</span> 2m <span class="hljs-params">--state-dir</span> <span class="hljs-string">/var/run/docker/libcontainerd/containerd</span> <span class="hljs-params">--shim</span> docker-containerd-shim <span class="hljs-params">--runtime</span> docker-runc</span><br><span class="line">root       4589   4333  0 20<span class="hljs-function">:22</span> pts/1    00<span class="hljs-function">:00</span><span class="hljs-function">:00</span> grep <span class="hljs-params">--color=auto</span> docker</span><br></pre></td></tr></table></figure><h2 id="七、测试docker是否能成功运行："><a href="#七、测试docker是否能成功运行：" class="headerlink" title="七、测试docker是否能成功运行："></a>七、测试docker是否能成功运行：</h2><figure class="highlight sqf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@workstudio docker]<span class="hljs-meta"># docker run hello-world</span></span><br><span class="line">Unable <span class="hljs-keyword">to</span> <span class="hljs-built_in">find</span> <span class="hljs-built_in">image</span> <span class="hljs-string">'hello-world:latest'</span> locally</span><br><span class="line">latest: Pulling <span class="hljs-keyword">from</span> library/hello-world</span><br><span class="line"><span class="hljs-number">78445</span>dd45222: Pull complete </span><br><span class="line">Digest: sha256:c5515758d4c5e1e838e9cd307f6c6a0d620b5e07e6f927b07d05f6d12a1ac8d7</span><br><span class="line">Status: Downloaded newer <span class="hljs-built_in">image</span> <span class="hljs-keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello <span class="hljs-keyword">from</span> Docker!</span><br><span class="line">This message shows that your installation appears <span class="hljs-keyword">to</span> be working correctly.</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">To</span> generate this message, Docker took the following steps:</span><br><span class="line"> <span class="hljs-number">1</span>. The Docker client contacted the Docker daemon.</span><br><span class="line"> <span class="hljs-number">2</span>. The Docker daemon pulled the <span class="hljs-string">"hello-world"</span> <span class="hljs-built_in">image</span> <span class="hljs-keyword">from</span> the Docker Hub.</span><br><span class="line"> <span class="hljs-number">3</span>. The Docker daemon created a new container <span class="hljs-keyword">from</span> that <span class="hljs-built_in">image</span> which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> <span class="hljs-number">4</span>. The Docker daemon streamed that output <span class="hljs-keyword">to</span> the Docker client, which sent it</span><br><span class="line">    <span class="hljs-keyword">to</span> your terminal.</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">To</span> <span class="hljs-keyword">try</span> something more ambitious, you can run an Ubuntu container <span class="hljs-keyword">with</span>:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, <span class="hljs-built_in">and</span> more <span class="hljs-keyword">with</span> a free Docker ID:</span><br><span class="line"> https:<span class="hljs-comment">//cloud.docker.com/</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">For</span> more examples <span class="hljs-built_in">and</span> ideas, visit:</span><br><span class="line"> https:<span class="hljs-comment">//docs.docker.com/engine/userguide/</span></span><br></pre></td></tr></table></figure><p>如果是第一次运行 <code>hello-world</code> ，这个 <code>docker-image</code> 由于它还不存在于本地，所以要下载它，这可能要用一点时间！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、docker的官方安装文档：&quot;&gt;&lt;a href=&quot;#一、docker的官方安装文档：&quot; class=&quot;headerlink&quot; title=&quot;一、docker的官方安装文档：&quot;&gt;&lt;/a&gt;一、docker的官方安装文档：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/installation/linux/centos/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/engine/installation/linux/centos/&lt;/a&gt;&lt;br&gt;由docker给的文档可以看出它也只是去配置了一个docker的yum源、然后就通过这个源来安装docker了；在这个文档下我们采用手工配置的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://hekliu.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://hekliu.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>tomcat出现的PermGen Space问题</title>
    <link href="https://hekliu.github.io/2019/09/30/tomcat%E5%87%BA%E7%8E%B0%E7%9A%84PermGen-Space%E9%97%AE%E9%A2%98/"/>
    <id>https://hekliu.github.io/2019/09/30/tomcat出现的PermGen-Space问题/</id>
    <published>2019-09-30T06:04:27.000Z</published>
    <updated>2019-09-30T08:55:05.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>最近做项目碰到了让我纠结的问题，tomcat服务器运行一段时间，总是会自动报异常：<code>java.lang.OutOfmemoryError: PermGen Space</code> 的错误，导致项目无法正常运行。</p><a id="more"></a><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>PermGen Space：指的是内存的永久保存区，该块内存主要是被JVM用来存放class和mete信息的，当class被加载loader 的时候就会被存储到该内存区中，与存放类的实例的 <code>heap</code> 区不同，java中的 <code>垃圾回收器GC</code> 不会在主程序运行期对PermGen space进行清理。</p><h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>当我们的应用中有很多的class时，很可能就会出现PermGen space的错误。<br>我们的tomcat在重启的时候，不是使用的 <code>./bin/shutdown.sh</code> 而是使用<code>kill -9 xxx</code>直接杀掉，这样的话，存在PermGen space里面的内存不会被释放的，这样多长进行 <code>kill</code> 之后，就会导致系统的内存被渐渐吃完了，直到最后tomcat报错。</p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p><strong>手动设置 <code>MaxPermSize</code> 的大小</strong></p><p>1.修改 <code>TOMCAT_HOME/bin/catalina.bat</code>文件<br>在<code>echo &quot;using CATALINA_BASE：$CATALINA_BASE&quot;</code>上面加入这一行内容：<br><figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">JAVA_OPTS</span>=%JAVA_OPTS% -server -XX:<span class="hljs-attribute">PermSize</span>=128m -XX:<span class="hljs-attribute">MaxPermSize</span>=512m</span><br></pre></td></tr></table></figure></p><p>2.如果是 <code>linux</code> 环境，则修改 <code>TOMCAT_HOME/bin/catalina.sh</code>:<br><figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">JAVA_OPTS</span>=<span class="hljs-string">"<span class="hljs-variable">$JAVA_OPTS</span>"</span> -server -XX:<span class="hljs-attribute">PermSize</span>=128m -XX:<span class="hljs-attribute">MaxSize</span>=512m</span><br></pre></td></tr></table></figure></p><p>3.修改 <code>TOMCAT_HOME/bin/catalina.bat</code> 文件的内容：<br>在 <code>%_EXECJAVA% %JAVA_OPTS%</code> 后面添加 <code>-Xms=256m -Xmx512m</code> </p><p><strong><em>注意：前后有空格的</em></strong><br><strong><em>例如： <code>%_EXECJAVA% %JAVA_OPTS% -Xms=256m -Xmx512m(空格)</code>后面的内容不变</em></strong></p><p>1.在关闭重启 <code>tomcat</code> 的过程中使用 <code>shutdown.sh</code> 而不是 使用 <code>kill -9</code> </p><p>2.如果使用 <code>shutdown.sh</code> 不能将<code>tomcat</code>关掉的话，就必须要使用 <code>kill -9</code> 来关闭了，这个时候只有手动的来回收垃圾了： 在 <code>linux</code> 命令下执行如下的命令，把缓存给丢弃掉。</p><figure class="highlight awk hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="hljs-number">3</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/vm/</span>drop_caches</span><br></pre></td></tr></table></figure><blockquote><p>关于 <code>drop_caches</code>内容可以参考：<a href="https://blog.csdn.net/wyzxg/article/details/7279986" target="_blank" rel="noopener">drop_caches</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h2&gt;&lt;p&gt;最近做项目碰到了让我纠结的问题，tomcat服务器运行一段时间，总是会自动报异常：&lt;code&gt;java.lang.OutOfmemoryError: PermGen Space&lt;/code&gt; 的错误，导致项目无法正常运行。&lt;/p&gt;
    
    </summary>
    
      <category term="tomcat" scheme="https://hekliu.github.io/categories/tomcat/"/>
    
    
      <category term="java基础" scheme="https://hekliu.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>对于一些HashMap的一些疑问</title>
    <link href="https://hekliu.github.io/2018/10/16/%E5%AF%B9%E4%BA%8EHashMap%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E9%97%AE/"/>
    <id>https://hekliu.github.io/2018/10/16/对于HashMap的一些疑问/</id>
    <published>2018-10-16T08:46:03.000Z</published>
    <updated>2019-09-30T09:29:00.240Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap的结构"><a href="#HashMap的结构" class="headerlink" title="HashMap的结构"></a>HashMap的结构</h2><p>数组的寻址快，但是数据的插入与删除速度不行。链表的插入与删除速度快，但是寻址速度不行。 那有没有一种两者兼具的数据结构，答案肯定是有的，那就是hash表。 <code>HashMap</code> 就是根据 <code>数组+链表</code> 的方式组成了 <code>hash</code> 表：</p><a id="more"></a><p><img src="/images/pic-1.png" alt="" title="1.png"></p><h2 id="对于HashMap的一些疑问"><a href="#对于HashMap的一些疑问" class="headerlink" title="对于HashMap的一些疑问"></a>对于HashMap的一些疑问</h2><p><img src="/images/pic-2.png" alt="" title="2.png"></p><h4 id="一、HashMap的resize过程是什么样的？"><a href="#一、HashMap的resize过程是什么样的？" class="headerlink" title="一、HashMap的resize过程是什么样的？"></a>一、HashMap的resize过程是什么样的？</h4><p>HashMap在put的时候会先检查当前数组的length,如果插入新的值的时候使得 length &gt; 0.75f * size<code>（f为加载因子，可以在创建hashMap时指定）</code>的话，会将数组进行扩容为当前容量的<code>2</code>倍。 扩容之后必定要将原有 hashMap 中的值拷贝到新容量的hashMap 里面，HashMap 默认的容量为<code>16</code>，加载因子为<code>0.75</code>， 也就是说当HashMap 中Entry的个数超过 <code>16 * 0.75 = 12</code>时, 会将容量扩充为 <code>16 * 2 = 32</code>，然后重新计算元素在数组中的位置，这是一个非常耗时的操作，所以我们在使用HashMap的时候如果能预先知道Map中元素的大小，预设其大小能够提升其性能。 resize代码：</p><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//HashMap数组扩容</span></span><br><span class="line"></span><br><span class="line">void resize(int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>) &#123;</span><br><span class="line"></span><br><span class="line">Entry[] oldTable = table;</span><br><span class="line"></span><br><span class="line">int oldCapacity = oldTable.length;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//如果当前的数组长度已经达到最大值，则不在进行调整</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line"></span><br><span class="line">threshold = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//根据传入参数的长度定义新的数组</span></span><br><span class="line"></span><br><span class="line">Entry[] <span class="hljs-keyword">new</span><span class="hljs-type">Table</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Entry</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//按照新的规则，将旧数组中的元素转移到新数组中</span></span><br><span class="line"></span><br><span class="line">transfer(<span class="hljs-keyword">new</span><span class="hljs-type">Table</span>);</span><br><span class="line"></span><br><span class="line">table = <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//更新临界值</span></span><br><span class="line"></span><br><span class="line">threshold = (int)(<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> * loadFactor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//旧数组中元素往新数组中迁移</span></span><br><span class="line"></span><br><span class="line">void transfer(Entry[] <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//旧数组</span></span><br><span class="line"></span><br><span class="line">Entry[] src = table;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//新数组长度</span></span><br><span class="line"></span><br><span class="line">int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>.length;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//遍历旧数组</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line"></span><br><span class="line">Entry e = src[j];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">src[j] = <span class="hljs-literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">Entry next = e.next;</span><br><span class="line"></span><br><span class="line">int i = indexFor(e.hash, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);<span class="hljs-comment">//放在新数组中的index位置</span></span><br><span class="line"></span><br><span class="line">e.next = <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>[i];<span class="hljs-comment">//实现链表结构，新加入的放在链头，之前的的数据放在链尾</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">new</span><span class="hljs-type">Table</span>[i] = e;</span><br><span class="line"></span><br><span class="line">e = next;</span><br><span class="line"></span><br><span class="line">&#125; <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是1.7中的代码，1.8中引入了红黑树的概念，代码会相对复杂一些。</p><h4 id="二、HashMap在扩容的时候为什么容量都是原来的2倍，即容量为2-n"><a href="#二、HashMap在扩容的时候为什么容量都是原来的2倍，即容量为2-n" class="headerlink" title="二、HashMap在扩容的时候为什么容量都是原来的2倍，即容量为2^n"></a>二、HashMap在扩容的时候为什么容量都是原来的2倍，即容量为2^n</h4><p>HashMap 在计算数组中key的位置时，使用的算法为：<br><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* Returns index for hash code h. */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2"; </span></span><br><span class="line"><span class="hljs-keyword">return</span> h &amp; (length<span class="hljs-number">-1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即对key的hashcode 与当前数组容量 -1 进行与操作 我们假设有一个容量为分别为 15 和 16 的hashMap ，有两个key的hashcode 分别为 4 和 5 ，进行indexFor操作之后：</p><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H &amp; (length <span class="hljs-number">-1</span>) hash &amp; table.length<span class="hljs-number">-1</span> <span class="hljs-number">4</span> &amp; (<span class="hljs-number">15</span> - <span class="hljs-number">1</span>) <span class="hljs-number">0100</span> &amp; <span class="hljs-number">1110</span> = <span class="hljs-number">0100</span> <span class="hljs-number">5</span> &amp; （ <span class="hljs-number">15</span> <span class="hljs-number">-1</span> ） <span class="hljs-number">0101</span> &amp; <span class="hljs-number">1110</span> = <span class="hljs-number">01004</span> &amp; (<span class="hljs-number">16</span> - <span class="hljs-number">1</span>) <span class="hljs-number">0100</span> &amp; <span class="hljs-number">1111</span> = <span class="hljs-number">0100</span> <span class="hljs-number">5</span> &amp; （ <span class="hljs-number">16</span> <span class="hljs-number">-1</span> ） <span class="hljs-number">0101</span> &amp; <span class="hljs-number">1111</span> = <span class="hljs-number">0101</span></span><br></pre></td></tr></table></figure><p>我们能够看到在容量为16时进行indexFor操作之后获得相同结果的几率要比容量为15时的几率要小，这样能够减少出现hash冲突的几率，从而提高查询效率。<code>2 ^ n</code>是一个非常神奇的数字。</p><h4 id="三、put时出现相同的hashcode会怎样？"><a href="#三、put时出现相同的hashcode会怎样？" class="headerlink" title="三、put时出现相同的hashcode会怎样？"></a>三、put时出现相同的hashcode会怎样？</h4><p>hashMap 里面存储的Entry对象是由数组和链表组成的，当key的hashcode相同时，数组上这个位置存储的结构就是链表，这时会将新的值插入链表的表头。进行取值的时候会先获取到链表，再对链表进行遍历，通过key.equals方法获取到值。<code>（hashcode相同不代表对象相同，不要混淆hashcode和equals方法）</code>所以声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。</p><h4 id="四、什么是循环链表？"><a href="#四、什么是循环链表？" class="headerlink" title="四、什么是循环链表？"></a>四、什么是循环链表？</h4><p>HashMap在遇到多线程的操作中，如果需要重新调整HashMap的大小时，多个线程会同时尝试去调整HashMap的大小，这时处在同一位置的链表的元素的位置会反过来，以为移动到新的<code>bucket</code>的时候，HashMap不会将新的元素放到尾部<code>（为了避免尾部遍历）</code>，这时可能会出现<code>A -&gt; B -&gt; A</code>的情况，从而出现死循环，这便是HashMap中的循环链表。 所以HashMap 是不适合用在多线程的情况下的，可以考虑尝试使用<code>HashTable</code> 或是 <code>ConcurrentHashMap</code></p><h4 id="五、如何正确使用HashMap提高性能"><a href="#五、如何正确使用HashMap提高性能" class="headerlink" title="五、如何正确使用HashMap提高性能"></a>五、如何正确使用HashMap提高性能</h4><p>在设置HashMap的时候指定其容量的大小，减少其resize的过程。</p><h4 id="六、JDK1-8对HashMap进行了哪些优化"><a href="#六、JDK1-8对HashMap进行了哪些优化" class="headerlink" title="六、JDK1.8对HashMap进行了哪些优化"></a>六、JDK1.8对HashMap进行了哪些优化</h4><p>jdk1.8在对hash冲突的key时，如果此bucket位置上的元素数量在10以下时，还是和原来一样使用链表来进行存储，这时寻址的时间复杂度为O(n),当元素数量超过10时，使用红黑树进行代替，这时寻址的时间复杂度为O(n)</p><h4 id="七、HashMap-与-HashTable、ConcurrentHashMap的区别"><a href="#七、HashMap-与-HashTable、ConcurrentHashMap的区别" class="headerlink" title="七、HashMap 与 HashTable、ConcurrentHashMap的区别"></a>七、HashMap 与 HashTable、ConcurrentHashMap的区别</h4><p>1.HashTable的方法是同步的，在方法的前面都有<code>synchronized</code>来同步，HashMap未经同步，所以在多线程场合要手动同步</p><p>2.HashTable不允许null值<code>(key和value都不可以)</code> ,HashMap允许null值<code>(key和value都可以)</code>。</p><p>3.HashTable有一个contains(Object value)功能和containsValue(Object value)功能一样。</p><p>4.HashTable使用Enumeration进行遍历，HashMap使用Iterator进行遍历。</p><p>5.HashTable中hash数组默认大小是11，增加的方式是 <code>old * 2 + 1</code>。HashMap中hash数组的默认大小是16，而且一定是2的指数。</p><p>6.哈希值的使用不同，HashTable直接使用对象的hashCode，而HashMap重新计算hash值，用与代替求</p><p>7.<code>ConcurrentHashMap</code>也是一种线程安全的集合类，他和HashTable也是有区别的，主要区别就是加锁的粒度以及如何加锁，<code>ConcurrentHashMap</code>的加锁粒度要比HashTable更细一点。将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><h4 id="八、ConcurrentHashMap-和-Hashtable-的区别"><a href="#八、ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="八、ConcurrentHashMap 和 Hashtable 的区别"></a>八、ConcurrentHashMap 和 Hashtable 的区别</h4><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><h5 id="底层数据结构："><a href="#底层数据结构：" class="headerlink" title="底层数据结构："></a>底层数据结构：</h5><p>JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <code>数组+链表</code> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p><h5 id="实现线程安全的方式（重要）："><a href="#实现线程安全的方式（重要）：" class="headerlink" title="实现线程安全的方式（重要）："></a>实现线程安全的方式（重要）：</h5><p>在JDK1.7的时候，<code>ConcurrentHashMap（分段锁）</code>对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。<code>（默认分配16个Segment，比Hashtable效率提高16倍。）</code>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 <code>Node数组+链表+红黑树</code>的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。<code>（JDK1.6以后 对 synchronized锁做了很多优化）</code>整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p><p>Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p><h4 id="九、HashMap-多线程操作导致死循环问题"><a href="#九、HashMap-多线程操作导致死循环问题" class="headerlink" title="九、HashMap 多线程操作导致死循环问题"></a>九、HashMap 多线程操作导致死循环问题</h4><p>在多线程下，进行 put 操作会导致 HashMap 死循环，原因在于 HashMap 的扩容 resize()方法。由于扩容是新建一个数组，复制原数据到数组。由于数组下标挂有链表，所以需要复制链表，但是多线程操作有可能导致环形链表。复制链表过程如下:<br>以下模拟2个线程同时扩容。假设，当前 HashMap 的空间为2（临界值为1），hashcode 分别为 0 和 1，在散列地址 0 处有元素 A 和 B，这时候要添加元素 C，C 经过 hash 运算，得到散列地址为 1，这时候由于超过了临界值，空间不够，需要调用 resize 方法进行扩容，那么在多线程条件下，会出现条件竞争，模拟过程如下：</p><p>线程一：读取到当前的 HashMap 情况，在准备扩容时，线程二介入</p><p><img src="/images/pic-3.png" alt="" title="3.png"></p><p>线程二：读取 HashMap，进行扩容</p><p><img src="/images/pic-4.png" alt="" title="4.png"></p><p>线程一：继续执行</p><p><img src="/images/pic-5.png" alt="" title="5.png"></p><p>这个过程为，先将 A 复制到新的 hash 表中，然后接着复制 B 到链头<code>（A 的前边：B.next=A）</code>，本来 <code>B.next=null</code>，到此也就结束了<code>（跟线程二一样的过程）</code>，但是，由于线程二扩容的原因，将 <code>B.next=A</code>，所以，这里继续复制A，让 <code>A.next=B</code>，由此，环形链表出现：<code>B.next=A</code>; <code>A.next=B</code></p><h3 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h3><ul><li><a href="https://blog.csdn.net/fjse51/article/details/55260493" target="_blank" rel="noopener">jdk1.8中ConcurrentHashMap的实现原理</a></li><li><a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/" target="_blank" rel="noopener">HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！</a> </li><li><a href="http://www.yuanrengu.com/index.php/2017-01-17.html" target="_blank" rel="noopener">HASHMAP、HASHTABLE、CONCURRENTHASHMAP的原理与区别</a></li><li><a href="https://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener">ConcurrentHashMap实现原理及源码分析</a></li><li><a href="https://blog.csdn.net/jianghuxiaojin/article/details/52006118#commentBox" target="_blank" rel="noopener">java-并发-ConcurrentHashMap高并发机制-jdk1.8</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HashMap的结构&quot;&gt;&lt;a href=&quot;#HashMap的结构&quot; class=&quot;headerlink&quot; title=&quot;HashMap的结构&quot;&gt;&lt;/a&gt;HashMap的结构&lt;/h2&gt;&lt;p&gt;数组的寻址快，但是数据的插入与删除速度不行。链表的插入与删除速度快，但是寻址速度不行。 那有没有一种两者兼具的数据结构，答案肯定是有的，那就是hash表。 &lt;code&gt;HashMap&lt;/code&gt; 就是根据 &lt;code&gt;数组+链表&lt;/code&gt; 的方式组成了 &lt;code&gt;hash&lt;/code&gt; 表：&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://hekliu.github.io/categories/java/"/>
    
    
      <category term="java基础" scheme="https://hekliu.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>学习使用git</title>
    <link href="https://hekliu.github.io/2018/08/30/%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8git/"/>
    <id>https://hekliu.github.io/2018/08/30/学习使用git/</id>
    <published>2018-08-30T03:24:03.000Z</published>
    <updated>2019-09-30T09:38:47.405Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GIT-（分布式版本控制系统）"><a href="#GIT-（分布式版本控制系统）" class="headerlink" title="GIT （分布式版本控制系统）"></a>GIT （分布式版本控制系统）</h3><p><code>Git(读音为/gɪt/)</code>是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。<code>Git</code> 是 <code>Linus Torvalds</code> 为了帮助管理 <code>Linux</code> 内核开发而开发的一个开放源码的版本控制软件。</p><a id="more"></a><ul><li><p>创建markdown文件</p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">touch</span> <span class="hljs-selector-tag">README</span><span class="hljs-selector-class">.md</span></span><br></pre></td></tr></table></figure></li><li><p>创建.gitignore文件</p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">touch</span> <span class="hljs-selector-class">.gitignore</span></span><br></pre></td></tr></table></figure></li><li><p>初始化仓库</p><figure class="highlight ebnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">git init</span></span><br></pre></td></tr></table></figure></li><li><p>查看变化</p><figure class="highlight ebnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">git status</span></span><br></pre></td></tr></table></figure></li><li><p>添加所有的变更文件</p><figure class="highlight dockerfile hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="hljs-keyword">add</span><span class="hljs-bash"> .</span></span><br></pre></td></tr></table></figure></li><li><p>只是提交到本地仓库中</p><figure class="highlight nginx hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">git</span> commit -am <span class="hljs-string">'first commit init project'</span></span><br></pre></td></tr></table></figure></li><li><p>添加到远程仓库中</p><figure class="highlight dockerfile hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="hljs-keyword">add</span><span class="hljs-bash"> origin ’git地址’</span></span><br></pre></td></tr></table></figure></li><li><p>查看当前分支</p><figure class="highlight ebnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">git branch</span></span><br></pre></td></tr></table></figure></li><li><p>本地仓库推送到远程仓库</p><figure class="highlight maxima hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master</span><br><span class="line"></span><br><span class="line"><span class="hljs-number">1</span>.如果是第一次整合项目到git上会提示失败，需要先git pull把现在远程分支上的文件拉到本地</span><br><span class="line">上来，</span><br><span class="line"><span class="hljs-number">2.</span>git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master，</span><br><span class="line"><span class="hljs-number">3</span>.如果再报错就强制推上去，git <span class="hljs-built_in">push</span> -u -f <span class="hljs-built_in">origin</span> master;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>查看远程分支</p><figure class="highlight armasm hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>-r</span><br></pre></td></tr></table></figure></li><li><p>在远程master上开一个v1.0分支</p><figure class="highlight armasm hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-symbol">git</span> checkout -<span class="hljs-keyword">b </span><span class="hljs-built_in">v1</span>.<span class="hljs-number">0</span> origin/master</span><br></pre></td></tr></table></figure></li><li><p>查看是否切换到新建的分支</p><figure class="highlight ebnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">git branch</span></span><br></pre></td></tr></table></figure></li><li><p>推送分支到远程</p><figure class="highlight maxima hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> HEAD -u</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;GIT-（分布式版本控制系统）&quot;&gt;&lt;a href=&quot;#GIT-（分布式版本控制系统）&quot; class=&quot;headerlink&quot; title=&quot;GIT （分布式版本控制系统）&quot;&gt;&lt;/a&gt;GIT （分布式版本控制系统）&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Git(读音为/gɪt/)&lt;/code&gt;是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。&lt;code&gt;Git&lt;/code&gt; 是 &lt;code&gt;Linus Torvalds&lt;/code&gt; 为了帮助管理 &lt;code&gt;Linux&lt;/code&gt; 内核开发而开发的一个开放源码的版本控制软件。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://hekliu.github.io/categories/git/"/>
    
    
      <category term="git的使用" scheme="https://hekliu.github.io/tags/git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
</feed>
