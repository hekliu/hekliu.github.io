<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘庆龙 | Hekliu</title>
  
  <subtitle>不为失败找借口，只为成功找方法！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hekliu.github.io/"/>
  <updated>2019-09-30T06:58:19.195Z</updated>
  <id>https://hekliu.github.io/</id>
  
  <author>
    <name>刘庆龙</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tomcat出现的PermGen Space问题</title>
    <link href="https://hekliu.github.io/2019/09/30/tomcat%E5%87%BA%E7%8E%B0%E7%9A%84PermGen-Space%E9%97%AE%E9%A2%98/"/>
    <id>https://hekliu.github.io/2019/09/30/tomcat出现的PermGen-Space问题/</id>
    <published>2019-09-30T06:04:27.000Z</published>
    <updated>2019-09-30T06:58:19.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>最近做项目碰到了让我纠结的问题，tomcat服务器运行一段时间，总是会自动报异常：<code>java.lang.OutOfmemoryError: PermGen Space</code> 的错误，导致项目无法正常运行。</p><a id="more"></a><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>PermGen Space：指的是内存的永久保存区，该块内存主要是被JVM用来存放class和mete信息的，当class被加载loader 的时候就会被存储到该内存区中，与存放类的实例的 <code>heap</code> 区不同，java中的 <code>垃圾回收器GC</code> 不会在主程序运行期对PermGen space进行清理。</p><h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>当我们的应用中有很多的class时，很可能就会出现PermGen space的错误。<br>我们的tomcat在重启的时候，不是使用的 <code>./bin/shutdown.sh</code> 而是使用<code>kill -9 xxx</code>直接杀掉，这样的话，存在PermGen space里面的内存不会被释放的，这样多长进行 <code>kill</code> 之后，就会导致系统的内存被渐渐吃完了，直到最后tomcat报错。</p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p><strong>手动设置 <code>MaxPermSize</code> 的大小</strong></p><p>1.修改 <code>TOMCAT_HOME/bin/catalina.bat</code>文件<br>在<code>echo &quot;using CATALINA_BASE：$CATALINA_BASE&quot;</code>上面加入这一行内容：<br><figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">JAVA_OPTS</span>=%JAVA_OPTS% -server -XX:<span class="hljs-attribute">PermSize</span>=128m -XX:<span class="hljs-attribute">MaxPermSize</span>=512m</span><br></pre></td></tr></table></figure></p><p>2.如果是 <code>linux</code> 环境，则修改 <code>TOMCAT_HOME/bin/catalina.sh</code>:<br><figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">JAVA_OPTS</span>=<span class="hljs-string">"<span class="hljs-variable">$JAVA_OPTS</span>"</span> -server -XX:<span class="hljs-attribute">PermSize</span>=128m -XX:<span class="hljs-attribute">MaxSize</span>=512m</span><br></pre></td></tr></table></figure></p><p>3.修改 <code>TOMCAT_HOME/bin/catalina.bat</code> 文件的内容：<br>在 <code>%_EXECJAVA% %JAVA_OPTS%</code> 后面添加 <code>-Xms=256m -Xmx512m</code> </p><p><strong><em>注意：前后有空格的</em></strong><br><strong><em>例如： <code>%_EXECJAVA% %JAVA_OPTS% -Xms=256m -Xmx512m(空格)</code>后面的内容不变</em></strong></p><p>1.在关闭重启 <code>tomcat</code> 的过程中使用 <code>shutdown.sh</code> 而不是 使用 <code>kill -9</code> </p><p>2.如果使用 <code>shutdown.sh</code> 不能将<code>tomcat</code>关掉的话，就必须要使用 <code>kill -9</code> 来关闭了，这个时候只有手动的来回收垃圾了： 在 <code>linux</code> 命令下执行如下的命令，把缓存给丢弃掉。</p><figure class="highlight awk hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="hljs-number">3</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/vm/</span>drop_caches</span><br></pre></td></tr></table></figure><blockquote><p>关于 <code>drop_caches</code>内容可以参考：<a href="https://blog.csdn.net/wyzxg/article/details/7279986" target="_blank" rel="noopener">drop_caches</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h2&gt;&lt;p&gt;最近做项目碰到了让我纠结的问题，tomcat服务器运行一段时间，总是会自动报异常：&lt;code&gt;java.lang.OutOfmemoryError: PermGen Space&lt;/code&gt; 的错误，导致项目无法正常运行。&lt;/p&gt;
    
    </summary>
    
      <category term="tomcat" scheme="https://hekliu.github.io/categories/tomcat/"/>
    
    
      <category term="java基础" scheme="https://hekliu.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>对于一些HashMap的一些疑问</title>
    <link href="https://hekliu.github.io/2018/10/16/%E5%AF%B9%E4%BA%8EHashMap%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E9%97%AE/"/>
    <id>https://hekliu.github.io/2018/10/16/对于HashMap的一些疑问/</id>
    <published>2018-10-16T08:46:03.000Z</published>
    <updated>2019-09-26T05:59:47.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap的结构"><a href="#HashMap的结构" class="headerlink" title="HashMap的结构"></a>HashMap的结构</h2><p>数组的寻址快，但是数据的插入与删除速度不行。 链表的插入与删除速度快，但是寻址速度不行。 那有没有一种两者兼具的数据结构，答案肯定是有的，那就是hash表。 HashMap 就是根据 数组+链表的方式组成了hash表：</p><a id="more"></a><p><img src="/images/pic-1.png" alt="" title="1.png"></p><h2 id="对于HashMap的一些疑问"><a href="#对于HashMap的一些疑问" class="headerlink" title="对于HashMap的一些疑问"></a>对于HashMap的一些疑问</h2><p><img src="/images/pic-2.png" alt="" title="2.png"></p><h4 id="一、HashMap的resize过程是什么样的？"><a href="#一、HashMap的resize过程是什么样的？" class="headerlink" title="一、HashMap的resize过程是什么样的？"></a>一、HashMap的resize过程是什么样的？</h4><p>HashMap在put的时候会先检查当前数组的length,如果插入新的值的时候使得length &gt; 0.75f <em> size（f 为加载因子，可以在创建hashMap时指定）的话，会将数组进行扩容为当前容量的2倍。 扩容之后必定要将原有hashMap 中的值拷贝到新容量的hashMap 里面，HashMap 默认的容量为16，加载因子为0.75， 也就是说当HashMap 中Entry的个数超过 16 </em> 0.75 = 12时, 会将容量扩充为 16 * 2 = 32，然后重新计算元素在数组中的位置，这是一个非常耗时的操作，所以我们在使用HashMap的时候如果能预先知道Map中元素的大小，预设其大小能够提升其性能。 resize代码：</p><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//HashMap数组扩容</span></span><br><span class="line"></span><br><span class="line">void resize(int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>) &#123;</span><br><span class="line"></span><br><span class="line">Entry[] oldTable = table;</span><br><span class="line"></span><br><span class="line">int oldCapacity = oldTable.length;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//如果当前的数组长度已经达到最大值，则不在进行调整</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line"></span><br><span class="line">threshold = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//根据传入参数的长度定义新的数组</span></span><br><span class="line"></span><br><span class="line">Entry[] <span class="hljs-keyword">new</span><span class="hljs-type">Table</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Entry</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//按照新的规则，将旧数组中的元素转移到新数组中</span></span><br><span class="line"></span><br><span class="line">transfer(<span class="hljs-keyword">new</span><span class="hljs-type">Table</span>);</span><br><span class="line"></span><br><span class="line">table = <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//更新临界值</span></span><br><span class="line"></span><br><span class="line">threshold = (int)(<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> * loadFactor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//旧数组中元素往新数组中迁移</span></span><br><span class="line"></span><br><span class="line">void transfer(Entry[] <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//旧数组</span></span><br><span class="line"></span><br><span class="line">Entry[] src = table;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//新数组长度</span></span><br><span class="line"></span><br><span class="line">int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>.length;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//遍历旧数组</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line"></span><br><span class="line">Entry e = src[j];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">src[j] = <span class="hljs-literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">Entry next = e.next;</span><br><span class="line"></span><br><span class="line">int i = indexFor(e.hash, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);<span class="hljs-comment">//放在新数组中的index位置</span></span><br><span class="line"></span><br><span class="line">e.next = <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>[i];<span class="hljs-comment">//实现链表结构，新加入的放在链头，之前的的数据放在链尾</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">new</span><span class="hljs-type">Table</span>[i] = e;</span><br><span class="line"></span><br><span class="line">e = next;</span><br><span class="line"></span><br><span class="line">&#125; <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是1.7中的代码，1.8中引入了红黑树的概念，代码会相对复杂一些。</p><h4 id="二、HashMap在扩容的时候为什么容量都是原来的2倍，即容量为2-n"><a href="#二、HashMap在扩容的时候为什么容量都是原来的2倍，即容量为2-n" class="headerlink" title="二、HashMap在扩容的时候为什么容量都是原来的2倍，即容量为2^n"></a>二、HashMap在扩容的时候为什么容量都是原来的2倍，即容量为2^n</h4><p>HashMap 在计算数组中key的位置时，使用的算法为：<br>/<em> </em> Returns index for hash code h. */<br>static int indexFor(int h, int length) {<br>// assert Integer.bitCount(length) == 1 : “length must be a non-zero power of 2”; return h &amp; (length-1); }</p><p>即对key的hashcode 与当前数组容量 -1 进行与操作 我们假设有一个容量为分别为15 和 16 的hashMap ，有两个key的hashcode 分别为4和5，进行indexFor操作之后：</p><p>H &amp; (length -1) hash &amp; table.length-1 4 &amp; (15 - 1) 0100 &amp; 1110 = 0100 5 &amp; （ 15 -1 ） 0101 &amp; 1110 = 0100<br>4 &amp; (16 - 1) 0100 &amp; 1111 = 0100 5 &amp; （ 16 -1 ） 0101 &amp; 1111 = 0101</p><p>我们能够看到在容量为16时进行indexFor操作之后获得相同结果的几率要比容量为15时的几率要小，这样能够减少出现hash冲突的几率，从而提高查询效率。2 ^ n是一个非常神奇的数字。</p><h4 id="三、put时出现相同的hashcode会怎样？"><a href="#三、put时出现相同的hashcode会怎样？" class="headerlink" title="三、put时出现相同的hashcode会怎样？"></a>三、put时出现相同的hashcode会怎样？</h4><p>hashMap 里面存储的Entry对象是由数组和链表组成的，当key的hashcode相同时，数组上这个位置存储的结构就是链表，这时会将新的值插入链表的表头。进行取值的时候会先获取到链表，再对链表进行遍历，通过key.equals方法获取到值。（hashcode相同不代表对象相同，不要混淆hashcode和equals方法） 所以声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。</p><h4 id="四、什么是循环链表？"><a href="#四、什么是循环链表？" class="headerlink" title="四、什么是循环链表？"></a>四、什么是循环链表？</h4><p>HashMap在遇到多线程的操作中，如果需要重新调整HashMap的大小时，多个线程会同时尝试去调整HashMap的大小，这时处在同一位置的链表的元素的位置会反过来，以为移动到新的bucket的时候，HashMap不会将新的元素放到尾部（为了避免尾部遍历），这时可能会出现A -&gt; B -&gt; A的情况，从而出现死循环，这便是HashMap中的循环链表。 所以HashMap 是不适合用在多线程的情况下的，可以考虑尝试使用HashTable 或是 ConcurrentHashMap</p><h4 id="五、如何正确使用HashMap提高性能"><a href="#五、如何正确使用HashMap提高性能" class="headerlink" title="五、如何正确使用HashMap提高性能"></a>五、如何正确使用HashMap提高性能</h4><p>在设置HashMap的时候指定其容量的大小，减少其resize的过程。</p><h4 id="六、JDK1-8对HashMap进行了哪些优化"><a href="#六、JDK1-8对HashMap进行了哪些优化" class="headerlink" title="六、JDK1.8对HashMap进行了哪些优化"></a>六、JDK1.8对HashMap进行了哪些优化</h4><p>jdk1.8在对hash冲突的key时，如果此bucket位置上的元素数量在10以下时，还是和原来一样使用链表来进行存储，这时寻址的时间复杂度为O(n),当元素数量超过10时，使用红黑树进行代替，这时寻址的时间复杂度为O(n)</p><h4 id="七、HashMap-与-HashTable、ConcurrentHashMap的区别"><a href="#七、HashMap-与-HashTable、ConcurrentHashMap的区别" class="headerlink" title="七、HashMap 与 HashTable、ConcurrentHashMap的区别"></a>七、HashMap 与 HashTable、ConcurrentHashMap的区别</h4><p>1.HashTable的方法是同步的，在方法的前面都有synchronized来同步，HashMap未经同步，所以在多线程场合要手动同步</p><p>2.HashTable不允许null值(key和value都不可以) ,HashMap允许null值(key和value都可以)。</p><p>3.HashTable有一个contains(Object value)功能和containsValue(Object value)功能一样。</p><p>4.HashTable使用Enumeration进行遍历，HashMap使用Iterator进行遍历。</p><p>5.HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</p><p>6.哈希值的使用不同，HashTable直接使用对象的hashCode，而HashMap重新计算hash值，用与代替求</p><p>7.ConcurrentHashMap也是一种线程安全的集合类，他和HashTable也是有区别的，主要区别就是加锁的粒度以及如何加锁，ConcurrentHashMap的加锁粒度要比HashTable更细一点。将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><h4 id="八、ConcurrentHashMap-和-Hashtable-的区别"><a href="#八、ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="八、ConcurrentHashMap 和 Hashtable 的区别"></a>八、ConcurrentHashMap 和 Hashtable 的区别</h4><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><h5 id="底层数据结构："><a href="#底层数据结构：" class="headerlink" title="底层数据结构："></a>底层数据结构：</h5><p>JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p><h5 id="实现线程安全的方式（重要）："><a href="#实现线程安全的方式（重要）：" class="headerlink" title="实现线程安全的方式（重要）："></a>实现线程安全的方式（重要）：</h5><p>在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p><p>Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p><h4 id="九、HashMap-多线程操作导致死循环问题"><a href="#九、HashMap-多线程操作导致死循环问题" class="headerlink" title="九、HashMap 多线程操作导致死循环问题"></a>九、HashMap 多线程操作导致死循环问题</h4><p>在多线程下，进行 put 操作会导致 HashMap 死循环，原因在于 HashMap 的扩容 resize()方法。由于扩容是新建一个数组，复制原数据到数组。由于数组下标挂有链表，所以需要复制链表，但是多线程操作有可能导致环形链表。复制链表过程如下:<br>以下模拟2个线程同时扩容。假设，当前 HashMap 的空间为2（临界值为1），hashcode 分别为 0 和 1，在散列地址 0 处有元素 A 和 B，这时候要添加元素 C，C 经过 hash 运算，得到散列地址为 1，这时候由于超过了临界值，空间不够，需要调用 resize 方法进行扩容，那么在多线程条件下，会出现条件竞争，模拟过程如下：</p><p>线程一：读取到当前的 HashMap 情况，在准备扩容时，线程二介入</p><p><img src="/images/pic-3.png" alt="" title="3.png"></p><p>线程二：读取 HashMap，进行扩容</p><p><img src="/images/pic-4.png" alt="" title="4.png"></p><p>线程一：继续执行</p><p><img src="/images/pic-5.png" alt="" title="5.png"></p><p>这个过程为，先将 A 复制到新的 hash 表中，然后接着复制 B 到链头（A 的前边：B.next=A），本来 B.next=null，到此也就结束了（跟线程二一样的过程），但是，由于线程二扩容的原因，将 B.next=A，所以，这里继续复制A，让 A.next=B，由此，环形链表出现：B.next=A; A.next=B</p><h3 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h3><ul><li><a href="https://blog.csdn.net/fjse51/article/details/55260493" target="_blank" rel="noopener">jdk1.8中ConcurrentHashMap的实现原理</a></li><li><a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/" target="_blank" rel="noopener">HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！</a> </li><li><a href="http://www.yuanrengu.com/index.php/2017-01-17.html" target="_blank" rel="noopener">HASHMAP、HASHTABLE、CONCURRENTHASHMAP的原理与区别</a></li><li><a href="https://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener">ConcurrentHashMap实现原理及源码分析</a></li><li><a href="https://blog.csdn.net/jianghuxiaojin/article/details/52006118#commentBox" target="_blank" rel="noopener">java-并发-ConcurrentHashMap高并发机制-jdk1.8</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HashMap的结构&quot;&gt;&lt;a href=&quot;#HashMap的结构&quot; class=&quot;headerlink&quot; title=&quot;HashMap的结构&quot;&gt;&lt;/a&gt;HashMap的结构&lt;/h2&gt;&lt;p&gt;数组的寻址快，但是数据的插入与删除速度不行。 链表的插入与删除速度快，但是寻址速度不行。 那有没有一种两者兼具的数据结构，答案肯定是有的，那就是hash表。 HashMap 就是根据 数组+链表的方式组成了hash表：&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://hekliu.github.io/categories/java/"/>
    
    
      <category term="java基础" scheme="https://hekliu.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>学习使用git</title>
    <link href="https://hekliu.github.io/2018/08/30/%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8git/"/>
    <id>https://hekliu.github.io/2018/08/30/学习使用git/</id>
    <published>2018-08-30T03:24:03.000Z</published>
    <updated>2019-09-27T02:55:04.449Z</updated>
    
    <content type="html"><![CDATA[<ul><li>创建markdown文件<figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">touch</span> <span class="hljs-selector-tag">README</span><span class="hljs-selector-class">.md</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>创建.gitignore文件</p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">touch</span> <span class="hljs-selector-class">.gitignore</span></span><br></pre></td></tr></table></figure></li><li><p>初始化仓库</p><figure class="highlight ebnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">git init</span></span><br></pre></td></tr></table></figure></li><li><p>查看变化</p><figure class="highlight ebnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">git status</span></span><br></pre></td></tr></table></figure></li><li><p>添加所有的变更文件</p><figure class="highlight dockerfile hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="hljs-keyword">add</span><span class="hljs-bash"> .</span></span><br></pre></td></tr></table></figure></li><li><p>只是提交到本地仓库中</p><figure class="highlight nginx hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">git</span> commit -am <span class="hljs-string">'first commit init project'</span></span><br></pre></td></tr></table></figure></li><li><p>添加到远程仓库中</p><figure class="highlight dockerfile hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="hljs-keyword">add</span><span class="hljs-bash"> origin ’git地址’</span></span><br></pre></td></tr></table></figure></li><li><p>查看当前分支</p><figure class="highlight ebnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">git branch</span></span><br></pre></td></tr></table></figure></li><li><p>本地仓库推送到远程仓库</p><figure class="highlight maxima hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master</span><br><span class="line"></span><br><span class="line"><span class="hljs-number">1</span>.如果是第一次整合项目到git上会提示失败，需要先git pull把现在远程分支上的文件拉到本地</span><br><span class="line">上来，</span><br><span class="line"><span class="hljs-number">2.</span>git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master，</span><br><span class="line"><span class="hljs-number">3</span>.如果再报错就强制推上去，git <span class="hljs-built_in">push</span> -u -f <span class="hljs-built_in">origin</span> master;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>查看远程分支</p><figure class="highlight armasm hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>-r</span><br></pre></td></tr></table></figure></li><li><p>在远程master上开一个v1.0分支</p><figure class="highlight armasm hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-symbol">git</span> checkout -<span class="hljs-keyword">b </span><span class="hljs-built_in">v1</span>.<span class="hljs-number">0</span> origin/master</span><br></pre></td></tr></table></figure></li><li><p>查看是否切换到新建的分支</p><figure class="highlight ebnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">git branch</span></span><br></pre></td></tr></table></figure></li><li><p>推送分支到远程</p><figure class="highlight maxima hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> HEAD -u</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;创建markdown文件&lt;figure class=&quot;highlight css hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;touch&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;README&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.md&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="git" scheme="https://hekliu.github.io/categories/git/"/>
    
    
      <category term="git的使用" scheme="https://hekliu.github.io/tags/git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
</feed>
