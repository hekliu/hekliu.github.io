{"pages":[{"title":"目录","text":"","link":"/categories/index.html"},{"title":"关于","text":"一个喜欢玩游戏，热爱编程的九零后少年…; 业余骑行，运动，看电影，偶尔打打游戏，单身狗的日常生活 (～￣▽￣)～写博客，撸代码，研究技术，提升自我","link":"/about/index.html"},{"title":"标签云","text":"","link":"/tags/index.html"}],"posts":[{"title":"对于一些HashMap的一些疑问","text":"HashMap的结构数组的寻址快，但是数据的插入与删除速度不行。链表的插入与删除速度快，但是寻址速度不行。 那有没有一种两者兼具的数据结构，答案肯定是有的，那就是hash表。 HashMap 就是根据 数组+链表 的方式组成了 hash 表： 对于HashMap的一些疑问 一、HashMap的resize过程是什么样的？HashMap在put的时候会先检查当前数组的length,如果插入新的值的时候使得 length &gt; 0.75f * size（f为加载因子，可以在创建hashMap时指定）的话，会将数组进行扩容为当前容量的2倍。 扩容之后必定要将原有 hashMap 中的值拷贝到新容量的hashMap 里面，HashMap 默认的容量为16，加载因子为0.75， 也就是说当HashMap 中Entry的个数超过 16 * 0.75 = 12时, 会将容量扩充为 16 * 2 = 32，然后重新计算元素在数组中的位置，这是一个非常耗时的操作，所以我们在使用HashMap的时候如果能预先知道Map中元素的大小，预设其大小能够提升其性能。 resize代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//HashMap数组扩容void resize(int newCapacity) {Entry[] oldTable = table;int oldCapacity = oldTable.length;//如果当前的数组长度已经达到最大值，则不在进行调整if (oldCapacity == MAXIMUM_CAPACITY) {threshold = Integer.MAX_VALUE;return;}//根据传入参数的长度定义新的数组Entry[] newTable = new Entry[newCapacity];//按照新的规则，将旧数组中的元素转移到新数组中transfer(newTable);table = newTable;//更新临界值threshold = (int)(newCapacity * loadFactor);}//旧数组中元素往新数组中迁移void transfer(Entry[] newTable) {//旧数组Entry[] src = table;//新数组长度int newCapacity = newTable.length;//遍历旧数组for (int j = 0; j &lt; src.length; j++) {Entry e = src[j];if (e != null) {src[j] = null;do {Entry next = e.next;int i = indexFor(e.hash, newCapacity);//放在新数组中的index位置e.next = newTable[i];//实现链表结构，新加入的放在链头，之前的的数据放在链尾newTable[i] = e;e = next;} while (e != null);}}} 这是1.7中的代码，1.8中引入了红黑树的概念，代码会相对复杂一些。 二、HashMap在扩容的时候为什么容量都是原来的2倍，即容量为2^nHashMap 在计算数组中key的位置时，使用的算法为：12345/* Returns index for hash code h. */static int indexFor(int h, int length) { // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\"; return h &amp; (length-1); } 即对key的hashcode 与当前数组容量 -1 进行与操作 我们假设有一个容量为分别为 15 和 16 的hashMap ，有两个key的hashcode 分别为 4 和 5 ，进行indexFor操作之后： 1H &amp; (length -1) hash &amp; table.length-1 4 &amp; (15 - 1) 0100 &amp; 1110 = 0100 5 &amp; （ 15 -1 ） 0101 &amp; 1110 = 01004 &amp; (16 - 1) 0100 &amp; 1111 = 0100 5 &amp; （ 16 -1 ） 0101 &amp; 1111 = 0101 我们能够看到在容量为16时进行indexFor操作之后获得相同结果的几率要比容量为15时的几率要小，这样能够减少出现hash冲突的几率，从而提高查询效率。2 ^ n是一个非常神奇的数字。 三、put时出现相同的hashcode会怎样？hashMap 里面存储的Entry对象是由数组和链表组成的，当key的hashcode相同时，数组上这个位置存储的结构就是链表，这时会将新的值插入链表的表头。进行取值的时候会先获取到链表，再对链表进行遍历，通过key.equals方法获取到值。（hashcode相同不代表对象相同，不要混淆hashcode和equals方法）所以声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。 四、什么是循环链表？HashMap在遇到多线程的操作中，如果需要重新调整HashMap的大小时，多个线程会同时尝试去调整HashMap的大小，这时处在同一位置的链表的元素的位置会反过来，以为移动到新的bucket的时候，HashMap不会将新的元素放到尾部（为了避免尾部遍历），这时可能会出现A -&gt; B -&gt; A的情况，从而出现死循环，这便是HashMap中的循环链表。 所以HashMap 是不适合用在多线程的情况下的，可以考虑尝试使用HashTable 或是 ConcurrentHashMap 五、如何正确使用HashMap提高性能在设置HashMap的时候指定其容量的大小，减少其resize的过程。 六、JDK1.8对HashMap进行了哪些优化jdk1.8在对hash冲突的key时，如果此bucket位置上的元素数量在10以下时，还是和原来一样使用链表来进行存储，这时寻址的时间复杂度为O(n),当元素数量超过10时，使用红黑树进行代替，这时寻址的时间复杂度为O(n) 七、HashMap 与 HashTable、ConcurrentHashMap的区别1.HashTable的方法是同步的，在方法的前面都有synchronized来同步，HashMap未经同步，所以在多线程场合要手动同步 2.HashTable不允许null值(key和value都不可以) ,HashMap允许null值(key和value都可以)。 3.HashTable有一个contains(Object value)功能和containsValue(Object value)功能一样。 4.HashTable使用Enumeration进行遍历，HashMap使用Iterator进行遍历。 5.HashTable中hash数组默认大小是11，增加的方式是 old * 2 + 1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 6.哈希值的使用不同，HashTable直接使用对象的hashCode，而HashMap重新计算hash值，用与代替求 7.ConcurrentHashMap也是一种线程安全的集合类，他和HashTable也是有区别的，主要区别就是加锁的粒度以及如何加锁，ConcurrentHashMap的加锁粒度要比HashTable更细一点。将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 八、ConcurrentHashMap 和 Hashtable 的区别ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。 底层数据结构：JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的； 实现线程安全的方式（重要）：在JDK1.7的时候，ConcurrentHashMap（分段锁）对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。）到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本； Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。 九、HashMap 多线程操作导致死循环问题在多线程下，进行 put 操作会导致 HashMap 死循环，原因在于 HashMap 的扩容 resize()方法。由于扩容是新建一个数组，复制原数据到数组。由于数组下标挂有链表，所以需要复制链表，但是多线程操作有可能导致环形链表。复制链表过程如下:以下模拟2个线程同时扩容。假设，当前 HashMap 的空间为2（临界值为1），hashcode 分别为 0 和 1，在散列地址 0 处有元素 A 和 B，这时候要添加元素 C，C 经过 hash 运算，得到散列地址为 1，这时候由于超过了临界值，空间不够，需要调用 resize 方法进行扩容，那么在多线程条件下，会出现条件竞争，模拟过程如下： 线程一：读取到当前的 HashMap 情况，在准备扩容时，线程二介入 线程二：读取 HashMap，进行扩容 线程一：继续执行 这个过程为，先将 A 复制到新的 hash 表中，然后接着复制 B 到链头（A 的前边：B.next=A），本来 B.next=null，到此也就结束了（跟线程二一样的过程），但是，由于线程二扩容的原因，将 B.next=A，所以，这里继续复制A，让 A.next=B，由此，环形链表出现：B.next=A; A.next=B 推荐阅读： jdk1.8中ConcurrentHashMap的实现原理 HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！ HASHMAP、HASHTABLE、CONCURRENTHASHMAP的原理与区别 ConcurrentHashMap实现原理及源码分析 java-并发-ConcurrentHashMap高并发机制-jdk1.8","link":"/2018/10/16/对于HashMap的一些疑问/"},{"title":"tomcat出现的PermGen Space问题","text":"问题：最近做项目碰到了让我纠结的问题，tomcat服务器运行一段时间，总是会自动报异常：java.lang.OutOfmemoryError: PermGen Space 的错误，导致项目无法正常运行。 介绍：PermGen Space：指的是内存的永久保存区，该块内存主要是被JVM用来存放class和mete信息的，当class被加载loader 的时候就会被存储到该内存区中，与存放类的实例的 heap 区不同，java中的 垃圾回收器GC 不会在主程序运行期对PermGen space进行清理。 原因：当我们的应用中有很多的class时，很可能就会出现PermGen space的错误。我们的tomcat在重启的时候，不是使用的 ./bin/shutdown.sh 而是使用kill -9 xxx直接杀掉，这样的话，存在PermGen space里面的内存不会被释放的，这样多长进行 kill 之后，就会导致系统的内存被渐渐吃完了，直到最后tomcat报错。 解决方法：手动设置 MaxPermSize 的大小 1.修改 TOMCAT_HOME/bin/catalina.bat文件在echo &quot;using CATALINA_BASE：$CATALINA_BASE&quot;上面加入这一行内容：1set JAVA_OPTS=%JAVA_OPTS% -server -XX:PermSize=128m -XX:MaxPermSize=512m 2.如果是 linux 环境，则修改 TOMCAT_HOME/bin/catalina.sh:1JAVA_OPTS=\"$JAVA_OPTS\" -server -XX:PermSize=128m -XX:MaxSize=512m 3.修改 TOMCAT_HOME/bin/catalina.bat 文件的内容：在 %_EXECJAVA% %JAVA_OPTS% 后面添加 -Xms=256m -Xmx512m 注意：前后有空格的例如： %_EXECJAVA% %JAVA_OPTS% -Xms=256m -Xmx512m(空格)后面的内容不变 1.在关闭重启 tomcat 的过程中使用 shutdown.sh 而不是 使用 kill -9 2.如果使用 shutdown.sh 不能将tomcat关掉的话，就必须要使用 kill -9 来关闭了，这个时候只有手动的来回收垃圾了： 在 linux 命令下执行如下的命令，把缓存给丢弃掉。 1echo 3 &gt; /proc/sys/vm/drop_caches 关于 drop_caches内容可以参考：drop_caches","link":"/2019/09/30/tomcat出现的PermGen-Space问题/"},{"title":"配置docker官方源并用yum安装docker","text":"一、docker的官方安装文档：https://docs.docker.com/engine/installation/linux/centos/由docker给的文档可以看出它也只是去配置了一个docker的yum源、然后就通过这个源来安装docker了；在这个文档下我们采用手工配置的方式。 二、配置一个docker用的源：1.为docker 增加一个新的yum配置文件； 1touch /etc/yum.repos.d/docker.repo 2.docker.repo的内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[docker-ce-stable]name=Docker CE Stable - $basearchbaseurl=https://download.docker.com/linux/centos/7/$basearch/stableenabled=1gpgcheck=0 #我把这里设置成了0、说明我信任了这个源，不对它的rpm进行检察gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-stable-debuginfo]name=Docker CE Stable - Debuginfo $basearchbaseurl=https://download.docker.com/linux/centos/7/debug-$basearch/stableenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-stable-source]name=Docker CE Stable - Sourcesbaseurl=https://download.docker.com/linux/centos/7/source/stableenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-edge]name=Docker CE Edge - $basearchbaseurl=https://download.docker.com/linux/centos/7/$basearch/edgeenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-edge-debuginfo]name=Docker CE Edge - Debuginfo $basearchbaseurl=https://download.docker.com/linux/centos/7/debug-$basearch/edgeenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-edge-source]name=Docker CE Edge - Sourcesbaseurl=https://download.docker.com/linux/centos/7/source/edgeenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-test]name=Docker CE Test - $basearchbaseurl=https://download.docker.com/linux/centos/7/$basearch/testenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-test-debuginfo]name=Docker CE Test - Debuginfo $basearchbaseurl=https://download.docker.com/linux/centos/7/debug-$basearch/testenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-test-source]name=Docker CE Test - Sourcesbaseurl=https://download.docker.com/linux/centos/7/source/testenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg 三、安装docker:12345678910111213141516171819202122232425262728sudo yum install docker-ceLoaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfileResolving Dependencies--&gt; Running transaction check---&gt; Package docker-ce.x86_64 0:17.03.1.ce-1.el7.centos will be installed--&gt; Processing Dependency: docker-ce-selinux &gt;= 17.03.1.ce-1.el7.centos for package: docker-ce-17.03.1.ce-1.el7.centos.x86_64--&gt; Running transaction check---&gt; Package docker-ce-selinux.noarch 0:17.03.1.ce-1.el7.centos will be installed--&gt; Finished Dependency ResolutionDependencies Resolved===================================================================================================================================== Package Arch Version Repository Size=====================================================================================================================================Installing: docker-ce x86_64 17.03.1.ce-1.el7.centos docker-ce-stable 19 MInstalling for dependencies: docker-ce-selinux noarch 17.03.1.ce-1.el7.centos docker-ce-stable 28 kTransaction Summary=====================================================================================================================================Install 1 Package (+1 Dependent package)Total download size: 19 MInstalled size: 19 MIs this ok [y/d/N]: y 四、直接下载rpm包的方式来安装： 1.我在安装docker的时候发现下载的速度只有 3kB/s ，然而文件大小有19M。就在我感觉安装无望的时候，我机智的想到了自己直接把rpm下载下来，看了下docker.repo 发现centos7的源地址是 https://download.docker.com/linux/centos/7/$basearch/stable 所以我只要去https://download.docker.com/linux/centos/7/x86_64/stable/Packages/ 用迅雷(我是会员有加速)把rpm包下载下来就行了。 下载如下文件： docker-ce-17.03.0.ce-1.el7.centos.x86_64.rpmdocker-ce-selinux-17.03.0.ce-1.el7.centos.noarch.rpm 五、安装docker:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748lltotal 19096-rwxrwxrwx 1 jianglexing jianglexing 19521288 May 30 20:05 docker-ce-17.03.0.ce-1.el7.centos.x86_64.rpm-rw-r--r-- 1 jianglexing jianglexing 29108 May 30 20:15 docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch.rpm[root@workstudio docker]# yum localinstall *Loaded plugins: fastestmirror, langpacksExamining docker-ce-17.03.0.ce-1.el7.centos.x86_64.rpm: docker-ce-17.03.0.ce-1.el7.centos.x86_64Marking docker-ce-17.03.0.ce-1.el7.centos.x86_64.rpm to be installedExamining docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch.rpm: docker-ce-selinux-17.03.0.ce-1.el7.centos.noarchMarking docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch.rpm to be installedResolving Dependencies--&gt; Running transaction check---&gt; Package docker-ce.x86_64 0:17.03.0.ce-1.el7.centos will be installed---&gt; Package docker-ce-selinux.noarch 0:17.03.0.ce-1.el7.centos will be installed--&gt; Finished Dependency ResolutionDependencies Resolved===================================================================================================================================== Package Arch Version Repository Size=====================================================================================================================================Installing: docker-ce x86_64 17.03.0.ce-1.el7.centos /docker-ce-17.03.0.ce-1.el7.centos.x86_64 65 M docker-ce-selinux noarch 17.03.0.ce-1.el7.centos /docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch 43 kTransaction Summary=====================================================================================================================================Install 2 PackagesTotal size: 65 MInstalled size: 65 MIs this ok [y/d/N]: yDownloading packages:Running transaction checkRunning transaction testTransaction test succeededRunning transaction Installing : docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch 1/2 setsebool: SELinux is disabled.libsemanage.semanage_direct_install_info: Overriding docker module at lower priority 100 with module at priority 400. Installing : docker-ce-17.03.0.ce-1.el7.centos.x86_64 2/2 Verifying : docker-ce-17.03.0.ce-1.el7.centos.x86_64 1/2 Verifying : docker-ce-selinux-17.03.0.ce-1.el7.centos.noarch 2/2 Installed: docker-ce.x86_64 0:17.03.0.ce-1.el7.centos docker-ce-selinux.noarch 0:17.03.0.ce-1.el7.centos Complete! 六、启动docker:12345[root@workstudio docker]# systemctl start docker[root@workstudio docker]# ps -ef | grep dockerroot 4458 1 1 20:22 ? 00:00:00 /usr/bin/dockerdroot 4465 4458 0 20:22 ? 00:00:00 docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runcroot 4589 4333 0 20:22 pts/1 00:00:00 grep --color=auto docker 七、测试docker是否能成功运行：1234567891011121314151617181920212223242526[root@workstudio docker]# docker run hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-world78445dd45222: Pull complete Digest: sha256:c5515758d4c5e1e838e9cd307f6c6a0d620b5e07e6f927b07d05f6d12a1ac8d7Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://cloud.docker.com/For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ 如果是第一次运行 hello-world ，这个 docker-image 由于它还不存在于本地，所以要下载它，这可能要用一点时间！","link":"/2019/09/30/配置docker官方源并用yum安装docker/"},{"title":"学习使用git","text":"GIT （分布式版本控制系统）Git(读音为/gɪt/)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 创建markdown文件 1touch README.md 创建.gitignore文件 1touch .gitignore 初始化仓库 1git init 查看变化 1git status 添加所有的变更文件 1git add . 只是提交到本地仓库中 1git commit -am 'first commit init project' 添加到远程仓库中 1git remote add origin ’git地址’ 查看当前分支 1git branch 本地仓库推送到远程仓库 123456git push -u origin master1.如果是第一次整合项目到git上会提示失败，需要先git pull把现在远程分支上的文件拉到本地上来，2.git push -u origin master，3.如果再报错就强制推上去，git push -u -f origin master; 查看远程分支 1git branch -r 在远程master上开一个v1.0分支 1git checkout -b v1.0 origin/master 查看是否切换到新建的分支 1git branch 推送分支到远程 1git push origin HEAD -u","link":"/2018/08/30/学习使用git/"}],"tags":[{"name":"java基础","slug":"java基础","link":"/tags/java基础/"},{"name":"git的使用","slug":"git的使用","link":"/tags/git的使用/"},{"name":"docker","slug":"docker","link":"/tags/docker/"}],"categories":[{"name":"tomcat","slug":"tomcat","link":"/categories/tomcat/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"docker","slug":"docker","link":"/categories/docker/"}]}